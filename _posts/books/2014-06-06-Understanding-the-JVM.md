---
layout: post
title: 《深入理解Java虚拟机》笔记
category: book
---

##Summary
总算把这本书差不多看完了，拖了挺长时间。收获不小，了解了不少jvm的东西，只是一时半会难以用到工作当中。这篇笔记就记录一些当先自己觉得有用的东西吧，有些知识点，每去了解一遍总会有新的收获。

---

##Java内存区域和内存溢出异常
Java虚拟机的内存区域大致可以分为这么几个部分：

 - 方法区
 - Java堆
 - 虚拟机栈
 - 本地方法栈
 - 程序计数器

其中方法区和Java堆是所有线程共享的，虚拟机栈、本地方法栈和程序计数器是每个线程独享的。

**程序计数器**：它可以当作是当前线程所执行的字节码的行号指示器。如果当前执行的是Java方法，那么这个计数器记录的是正在执行的虚拟机字节码指令的地址，在虚拟机的概念模型里就是通过改变这个计数器的值来选取下一条执行的字节码指令。Java的多线程是通过线程切换并分配处理器时间来实现的，所以每个线程需要有自己的程序计数器。

**虚拟机栈**：虚拟机栈也是线程私有的，虚拟机栈描述的是Java方法执行的内存模型，每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。每一个方法的执行过程就对应着一个栈帧在虚拟机栈里入栈出栈的过程。（局部变量表所需要的内存空间在编译期分配完成）

**本地方法栈**：和虚拟栈作用相似，只不过虚拟机栈为Java方法服务，而本地方法栈为虚拟机使用的Native方法服务。

**Java堆**：虚拟机内容管理中最大的一块，被所有线程共享。此内存唯一的目的就是存放对象实例，几乎所有的对象实例都放在这里分配内存。Java堆是垃圾回收的只要区域，物理上可以不连续，只要逻辑上连续即可。

**方法区**：用于存储已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。这一区域也会被一些人叫做“永久代”，意思是这块内存里面的东西永远存在。其实方法区也会进行内存回收，主要是针对常量池的回收和类型的卸载，但是这两项操作一般效果不怎么样。

**运行时常量池**：方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息之外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内存在类加载之后会进入方法区的运行时常量池，一般来说还会把符号引用翻译出来的直接引用放入运行时常量池。运行期间也有可能有新的常量放入，比如String的intern()方法。

**直接内存**：这部分好象是跟NIO有关系。

上述这些内存区域，除了程序计数器之外都有可能抛出OutOfMemoryError异常，而且对于虚拟机栈，如果线程请求的栈深度大于虚拟机允许的最大深度，会抛出StackOverflowError。

>在作者重现内存溢出和StarclOverFlow的时候，对于虚拟机栈即使内存不够了抛出的也是StackOverflow。
在JDK1.6中intern()方法会把首次遇到的字符串实例复制到方法区，然后返回的是方法区中这个实例的引用，1.7中则不会复制，只是在常量池中记录首次出现的实例引用。

---

##垃圾收集器与内存分配策略

很多地方说判断对象是否存活的算法是这样的：每个对象都有自己的一个引用计数器，每有一个地方引用该对象。它的引用计数器的值加1，当引用失效的时候计数器的值减1，任何时刻计数器的值为0的对象就是不可能再次被使用的，也就是可以垃圾回收的。这个引用计数法简单高效，但主流Java虚拟机并不是这么做的，主要是无法解决对象之间的循环引用。

主流实现是通过可达性分析来判断的，这个算法基本是通过一系列称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象不可用，可以被回收。可作为GC Roots的几类对象有：

 - 虚拟机栈（栈帧的本地变量表）中引用的对象
 - 方法区中常量引用的对象
 - 方法区中类静态属性引用的对象
 - 本地方法栈中JNI（一般说的Native方法）引用的对象

要真正宣告一个对象的死亡需要经历两次标记：如果对象被判定为不可达，这是进行第一次标记并进行筛选，筛选的条件是该对象是否有必要执行finalize()方法（当对象没有覆盖该方法，或者该方法已经执行过了，这种时候被视为“没有必要执行”），如果有必要执行，则将该对象放入F-Queue队列中，虚拟机会有一个低级线程去执行这些对象的finalize()方法，这是它们避免被回收最后的机会。

###垃圾收集算法
 1. 标记-清除算法
    首先标记出所有需要回收的对象，然后统一回收。
    缺点：标记和回收效率都不高，而且会产生不连续的碎片。
 2. 复制算法
    简单来说就是划分两块相同的内存区域，一次用一块，需要回收对象的时候把所有还存活的复制到另外一块里面去。
    现在的商业虚拟机都是这样算法来回收新生代，新生代可细分为Eden空间、From Survivor空间和To Survivor空间。Eden和From里面存活的，放到To里面去，如果To放不下，直接放老年代里面（老年代进行内存担保）。
 3. 标记-整理算法
    跟标记-清除差不多，主要是标记只有让所有存活的对象向一端移动，然后直接清除掉边界以外的就行。
 4. 分代回收
    分老年代和新生代，新生代采用复制算法，老年代采用标记-清除或者整理算法。
    
>HotSpot算法实现：虚拟机应当有办法直接得知哪些地方存放着对象引用，在HotSpot中使用一组称为OopMap的数据结构来达到目的，然后还有安全点和安全区域的概念，都是为了GC。

###垃圾收集器

 - Serial收集器
    单线程收集，必须暂停其他所有工作线程（Stop The World）
    简单高效，对于单CPU环境，没有线程交互的开销
 - ParNew收集器 
    Serial的多线程版本，单CPU情况下不见得比Serial效率高
    CPU越多这个收集器效率越好，默认开启的收集线程数根CPU个数一样。
 - Parallel Scavenge收集器
    “吞吐量优先”收集器，比较在意吞吐量这样可以高效的利用CPU,尽快完成任务，主要适合在后台运算不需要太多交互的任务。（其他收集器都会比较注意停顿时间，良好的响应时间可以提升用户体验）
    该收集器有GC自适应调节策略，就是虚拟机会根据运行状况，自动调节新生代大小、Eden和Servivor的比例和晋升老年代对象年龄等参数，以提供最合适的停顿时间和最大的吞吐量。
 - Serial Old收集器 和 Parllel Old
    Serial和Parllel的老年代版本，都使用“标记-整理”算法
 - CMS收集器
    一种以获取最短回收停顿时间为目标的收集器，整个过程分四个步骤：
    - 初始标记
    - 并发标记
    - 重新标记
    - 并发清除
    缺点：对CPU资源敏感、无法处理浮动垃圾、基于“标记-清除”算法顶不住的时候会进行FullGC开启内存碎片的合并整理过程。
 - G1收集器
    G1是一款面向服务器端应用的垃圾收集器，优点：并行并发、分代收集、空间整合、可预测的停顿。
    过程：初始标记、并发标记、最终标记、筛选回收。

几条普遍的内存分配策略：
 - 对象优先分配在Eden中
    Eden空间不足的时候进行一次MinorGC(新生代垃圾回收)
 - 大对象直接进入老年代
    设置-XX:PretenureSizeThreshold，令大于这个设置值的对象直接进入老年代
 - 长期存活的对象将进入老年代
    设置-XX:MaxTenuringThreshold，晋升老年代的年龄阀值
 - 动态对象年龄判断
    如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于等于该年龄的对象直接进入老年代。
 - 空间分配担保
    MinorGC之后如果大量对象存活，急需要老年代进行担保，Servivor无法存放的对象直接进入老年代，老年代还放不下的话那么就是担保失败了，需要进行FullGC

>这一部分个人觉得差不多了解内存是怎么分配的，每一个内存块都是用来做什么的，垃圾回收的策略和几个算法，以及对象的存储（怎么从新生代进入老年代呀）这些就差不多了，垃圾收集器大致能有个印象记得名字就行。垃圾收集器的优劣，每个是怎么工作的，这些略深入。

---

##类文件结构

文件结构这个没什么好写的，写几个关键字好了。

 - 魔数与Class文件版本
 - 常量池
 - 访问标志
 - 类索引、父类索引和接口索引集合
 - 字段表集合
 - 方法表集合
 - 属性表集合
    - Code属性（操作数栈最大深度、局部变量表空间、代码字节和异常表等）
    - Exceptions属性（列出方法可能抛出的受检异常）
 - 字节码指令简介
 
>这部分主要是后面的基础，大致有印象就好，没必要都记住。

---

##虚拟机类加载机制

类加载的顺序：加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载。
加载，验证，准备，初始化和卸载这5个步骤是按部就班的开始，解析阶段就不一定了。这些阶段通常都是交叉进行，通常会在一个阶段的执行过程中激活另外一个阶段。

###加载
主要完成三件事情：

- 通过类的权限定名获取此类的二进制字节流；
- 将这个类转化为方法区的运行时数据结构；
- 在内存中生成代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。
这里没有规定从何处获取二进制流，所以也给加载类留下了很大空间，从zip, jar加载啊，从网络加载啊 各种方式。

###验证
- 文件格式验证
  基于二进制字节流进行验证，通过验证之后才会进入内存的方法区中进行存储（后面的验证全部基于方法区的存储结构进行）
  主要是验证字节流是否符合Class文件格式规范
  _（是否魔数开头，版本号是否在可处理范围之内……）_
- 元数据验证
  主要是对类的元数据信息进行语义检验，保证不存在不符合Java语法规范的元数据。
  _（继承的父类是否存在， 是否覆盖父类final字段……）_
- 字节码验证
  主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
  _（保证跳转指令不会跳转到方法体以外的字节码指令上，在操作栈放置一个int类型数据使用时却被当成long类型来加载入本地变量表……）_
- 符号引用验证
  主要发生在虚拟机将符号引用转化为直接引用的时候，（这个转化动作发生在解析阶段），符号引用验证可以看作是对类自身以外的信息进行匹配性校验。
  _(符号引用中通过字符串的全限定名，是否能找到对应的类， 符号引用中的类、字段、方法的访问性，是否可被当前类访问……)_
  （如果无法通过符号引用验证，可能会有NoSuchFieldError, NoSuchMethodError等）

###准备

准备阶段正式为类变量分配内存，并设置类变量初始值。
这里用到的内存都在方法区中进行。
这时候进行分配的仅包括类变量（static修饰），不包括实例变量（实例变量跟着实例化对象分配在Java堆中）
这里所谓的初始值通常是数据的零值。（int:0, boolean:false）
真正的赋值操作在初始化阶段进行，如果类变量是常量，则在准备阶段会对其赋值。

###解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类
（假设当前类是D，要把一个从未解析过得符号引用N解析为一个类或接口C的直接引用。）

- 类或者接口的解析
  - 如果C不是一个数组，D的类加载器去加载C类，加载过程中由于元数据验证，字节码验证，又有可能触发加载其他类
  - 如果C是一个数组，按照第一步加载数组元素类
  - 验证访问权限
- 字段解析  
    - 解析字段所属的类或者接口
  - C本身就包含简单名称和字段描述符都与目标匹配的字段，则返回
  - 如果在C中实现了接口，则会按照继承关系自下而上递归搜索父接口，找到则返回
  - 如果C不是Object类，则按照继承关系自下而上搜索父类，找到则返回
  - NoSuchFieldError exception
  - 验证访问权限
- 类方法解析
  基本同字段解析
  如果在C实现的接口或者父接口中找到了，说明C是一个抽象类，这是查找结束抛出java.lang.AbstractMethodException
- 接口方法解析
  - 如果C是一个类而非接口，抛出java.lang.IncompatibleClassChangeError
  - 在接口C中找到，返回
  - 在C父接口中找到，返回
  - NoSuchMethodError
  （接口默认访问权限是public，所以不存在权限问题）

###初始化

初始化阶段是执行类构造器`<client>()`方法的过程,`<client>()`方法是编译器自动生成的，相当于所有类变量的赋值操作和静态语句块的集合。
`<client>()`方法与构造方法不同，不需要显示的调用父类的`<client>()`方法，虚拟机会确保子类的被执行之前，父类的已经被执行，所以最先执行的是Object的`<client>()`方法。该方法并不是必需的。

有且只有五种情况需要立即对类进行初始化（加载，验证，准备自然需要在之前进行）

- 遇到new， getstatic， putstatic或者involestatic
- 使用reflect包的方法对类进行反射调用的时候
- 当初始化一个类的时候，如果发现其父类还未初始化，则需要先初始化其父类
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法），虚拟机会先初始化这个主类
- 当使用jdk7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic, REF_putStatic, REF_invkeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

不需要初始化的情况：

- 通过子类引用父类的静态字段，不会导致子类初始化
- 通过数组定义来引用类，不会触发此类的初始化
- 常量在编译阶段会存入调用类的的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

>接口初始化和类初始化的不同：
接口初始化的时候并不要求其父接口全部初始化，只有在真正使用到父接口的时候（如引用父接口中的常量），才会初始化。

**类加载器**：实现，通过一个类的全限定名来获取描述此类的二进制字节流，这个动作的代码模块
比较两个类是否相等前提之一是这两个类被同一个类加载器加载。
启动类加载器（C++）（加载`<JAVA_HOME>\lib`目录的），扩展类加载器，应用程序类加载器。
**双亲委派模型**：如果一个类加载器收到了类加载的请求，它不会自己尝试加载这个类，而是交给父加载器去完成，如果父类完成不了，它才自己去加载。
OSGI对双亲委派模型有破坏，在它的环境下类加载器不是树形结构，而是网状的。
  
---

##虚拟机字节码执行引擎

###栈帧
栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。
    
- 局部变量表
  用于存放方法参数和方法内的局部变量，最小单位是变量槽(Slot)。局部变量表的最大容量存放在方法的Code属性的max_locals里面。
  类变量有两次赋值操作，一次是准备阶段，赋系统初始值；二是初始化阶段，赋用户定义的初始值。一个局部变量定义了但是没有赋初始值是不可能使用的。
- 操作数栈
  最大深度也是在编译的时候存放在Code属性的max_stacks里面。
  `int a = 100;` 100会作为一个操作数，先被放到操作数栈里，然后赋值给a，这个值会被复制到局部变量表里（a是局部变量）。
- 动态连接
  符号引用一部分在类加载或者第一次使用的时候就转化为直接引用，这种转化是静态转化；一部分是在第一次运行期间转化为直接引用，这部分成为动态引用。（这部分的解释，不理解）
- 方法返回地址
  方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。异常退出时，要通过异常表确定，栈帧中不保存这个信息。

###方法调用

- 解析
  方法调用目标在代码写好，编译器进行编译时就必须确定下来，这类方法的调用称为解析。（编译器可知，运行期不可变。）解析调用一点是个静态过程，编译期即可完成。
  Java虚拟机提供的5条方法调用字节码
    - invokestatic:调用静态方法
    - invokespecial:调用实例构造器`<init>`方法、私有方法和父类方法
    - invokevirtual:调用所有虚方法（除静态方法、私有方法、实例构造其和父类方法这四类之外）
    - invokeinterface:调用接口方法，会在运行时再确定一个实现此接口的对象
    - invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法
- 分派
  - 静态分派  
  所有依赖静态类型（声明类型）来定位方法执行版本的分派动作被称为静态分派。
  静态分配例子可以参考方法的重载。方法重载这种虽然存在多个方法拥有相同名字，但是说在编译的时候，就可以确定会调用那个方法。
  >虚拟机在重载时是通过参数的_静态类型(声明类型)_而不是实际类型作为判定依据的。
  >Java里面自动类型转换的一个顺序：char -> int -> long -> float -> double -> character -> seriablizable -> object -> 变长参数
  解析和分派是在不同层次上筛选确定目标方法的过程。
  - 动态分派 
    在运行过程中根据实际类型确定方法执行版本的分派过程称为动态分派。
    动态分配的例子可以参考多态性的方法重写，只有到运行的时候，虚拟机才知道方法调用的目标是哪个。（也就是说调用父类的这个方法还是子类的这个方法）
    动态分配的方法调用，用的是invokevirtual指令，这个指令运行时解析过程大致是这样的：找到当前操作数栈顶的第一个元素所指向的对象（记做C），如果在C中能找到与常量中的描述符和简单名称都相符的方法，然后验证权限，如果权限OK就查找结束，如果权限不行抛IllegalAccessError异常；如果找不到，去C的父类里面遍历找，；如果始终没找到，抛AbstractMethodError。
  - 宗量
    方法的接收者和方法的参数统称为方法的宗量。静态分配属于多分派类型，动态分配属于单分派类型。
- 动态类型语言支持
  Java里面的这个动态调用，用到了invokedynamic这个指令，该指令第一个参数是引导方法，后面一个参数包含两项，方法类型和名称。引导方法有其固有参数，返回值是一个CallSite对象，CallSite对象像是对真正要调用的方法的一个引用。虚拟机找到并执行引导方法，从而获得一个CallSite对象，最终调用要执行的目标方法。
  书中给的例子的逻辑是这样的：调用LookUp的findStatic()方法，产生testMethod()方法的MethodHandler，然后用它创建一个ConstantCallSite对象，最后这个对象返回给invokedynamic指令，实现对testMethod方法的调用，incokedynamic指令的调用到此结束。

 >动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期。变量无类型而变量值有类型。

MethodHandle和Reflection的一些区别：实现的功能看起来是一样的，本质是来说反射是代码层次的，MethodHandle是字节码层次的；反射Method对象包含的内容远比MethodHandle要多；MethodHandle是字节码层次上的实现，这样一来可服务于所有运行在Java虚拟机上的语言。

###基于栈与基于寄存器的指令集
基于栈的指令集可移植，基于寄存器的更快

---

##Java内存模型与线程
关于Java内存模型的定义：我觉得是这样的，Java内存模型定义了虚拟机内存中变量的访问规则。
虚拟中每个线程都有自己的工作内容，然后共享主内存。
Java内存模型定义了8种原子操作来完成工作内容和主内存的通信：lock, unlock, read, load, use, assign, store, write。read和load， store和write不允许单独出现。
如果对一个变量执行lock操作，那么将清空工作内存中此变量的值，再次使用的时候需要重新从主内存获取。
对一个变量执行unlock操作之前，必须将此变量的值，同步回主内存。

###volatile
一个变量被volatile修饰之后，保证此变量对所有线程可见，也就是说一个线程修改了该变量的值之后，其他线程能够立即得知。做到这一点其实是因为volatile修饰的变量，禁止指令重排优化，当读一个volatile变量的时候工作内存中该变量的值设置为无效，直接从主内存读；当写一个volatile变量的时候，从工作内存同步回主内存。volatile的读写都是原子操作，但是这并不代表volatile是并发写安全的，它并不能当作多线程环境下的计数器。

Java内存模型是围绕在并发过程中如何处理原子性、可见性和顺序性这三个特征来建立的。对于可见性：synchronized的可见性是由“对一个变量执行unlock之前，必须先把此变量同步回主内存中”这条规则保证的；final的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this的引用传递出去，那么其他线程就可以看到这个final变量的值。

###happens-before（先行发生原则）
Java内存模型中定义的两项操作之间的偏序关系，意思就是如果A happens-before B, 那么A的操作对B可见。
Java内存模型中天然支持的先行发生关系有：

- 程序次序规则， 在同一线程内，按照程序控制流，写在前面的代码先行发生于写在后面的。
- 管程锁定规则， 一个unlock先行发生于后面对同一个锁的lock。 
- volatile变量规则
- 线程启动规则， 所有操作都在start之后
- 线程终止规则， 所有操作都在线程终止之前
- 线程中断规则， interrupt之后才会检测到中断事件的发生
- 对象终结规则， 初始化操作在finalize之前
- 传递性

如果A先行发生于B，并不代表在时间上A一定比B先执行，因为有指令重排的存在！！

---

##Java线程
JavaAPI中一个native方法，通常也就意味着这个方法没有使用或者无法使用平台无关的手段去实现。（当然也有可能是为了执行效率而使用native方法，不过通常最高效的手段就是平台相关的）
程序一般不直接使用内核线程，而是使用内核线程的一种高级接口--轻量级线程

线程安全：
定义一：
> 如果一个对象可以安全地被多个线程同时访问，那么它就是线程安全的

定义二：
> 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。

关于这两个定义，第一个很好理解但是也没什么有效的信息，第二个好像不是不理解……

线程安全的实现方法：

 - 互斥同步（临界区、互斥量和信号量都是主要的互斥实现方式）
 - 非阻塞同步（CAS）
 - 无同步方案（代码可重入，线程本地存储）

> 悲观并发策略：认为只要不做正确的同步那就肯定会出现问题
乐观并发策略：先进性操作，如果当前没有其他线程共享数据，那就操作成功了；如果共享数据有争用产生了冲突，那就采取补偿措施。（通常是不断重试，直到成功）

###锁优化
 - 在获取锁之前先让线程忙循环（自旋），主要是因为挂起和恢复线程这样开销比较大，先自旋着，如果很快能获得锁那就省去了线程休眠和唤起这两步操作；自旋时间会根据之前线程自旋的状况来调节，如果之前线程即使自旋了也很少成功获得锁，还是得挂起，那么之后可能就没有自旋直接挂起了。
 - 锁消除，如果一直是这一个线程去获取锁。
 - 锁粗化，扩大锁的范围。
 - 偏量锁 -> 轻量级锁 -> 重量级锁， 这部分可参考[这里](http://ifeve.com/java-synchronized/)

  
